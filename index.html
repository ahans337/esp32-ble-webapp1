<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ESP32 BLE Graph</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
    let charCOM = null;
  </script>
</head>
<body>
  <h2>ESP32 BLE Live Data</h2>
  <button onclick="connectToESP32()">Connect to ESP32 BLE</button>
  <button onclick="scanServices()">Scan Services</button>
  <canvas id="chart" width="600" height="300"></canvas>

  <input type="text" id="inputBox" placeholder="Enter mass (lbs)"> <!-- This is the weight entry box -->
  <button onclick="sendToESP32()">Send to ESP32</button>

  <script>
    const serviceUUID = 'e2164c18-4049-483d-8c74-8a7d382f2834';
    const charUUID    = 'd34db33f-dead-beef-cafe-babec0010001';

    let chart;
    const data = [];
    const labels = [];
    const fullData = [];

    // Initialize Chart
    window.onload = () => {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Total Force (N)',
            borderColor: 'blue',
            data: data,
            fill: false
          }]
        },
        options: {
          animation: false,
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time (s)'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Total Force (N)'
              }
            }
          }
        }
      });
    };

    // Connect and start plotting
    async function connectToESP32() {
      try {
        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [serviceUUID]
        });

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(serviceUUID);
        const characteristic = await service.getCharacteristic(charUUID);

        await characteristic.startNotifications();
        characteristic.addEventListener('characteristicvaluechanged', handleNotification);

        charCOM = await service.getCharacteristic("b21d2927-093b-4c5b-9b6a-0555cde8cee5");
        console.log("‚úÖ COM Characteristic ready:", charCOM.uuid);

        console.log("‚úÖ Connected and listening for notifications...");
      } catch (error) {
        console.error('Bluetooth connection failed:', error);
      }
    }
async function sendToESP32() {
  const input = document.getElementById("inputBox").value;
  if (!charCOM) {
    alert("‚ùå Not connected to ESP32 or COM characteristic not found.");
    return;
  }

  if (input.trim() === "") {
    alert("‚ö†Ô∏è Input cannot be empty.");
    return;
  }

  try {
    const encoder = new TextEncoder();
    await charCOM.writeValue(encoder.encode(input.trim()));
    console.log("üì§ Sent to ESP32:", input.trim());
  } catch (error) {
    console.error("‚ùå Failed to write to ESP32:", error);
  }
}
    // Scan available services and characteristics
    async function scanServices() {
      try {
        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [serviceUUID]
        });

        const server = await device.gatt.connect();
        const services = await server.getPrimaryServices();

        for (const service of services) {
          console.log('üîé Found service:', service.uuid);
          const characteristics = await service.getCharacteristics();
          for (const characteristic of characteristics) {
            console.log('  ‚Ü≥ Characteristic:', characteristic.uuid);
          }
        }
      } catch (error) {
        console.error('Service scan failed:', error);
      }
    }

    // Handle BLE notifications
function handleNotification(event) {
  const value = new TextDecoder('utf-8').decode(event.target.value);
  console.log("üîî Notification received:", value.trim());

  const parts = value.trim().split(",");
  if (parts.length < 2) {
    console.warn("‚ö†Ô∏è Invalid BLE data format:", value);
    return;
  }

  const timeMs = parseInt(parts[0]);           // from ESP millis()
  const totalForce = parseFloat(parts[1]);     // from ESP calculation

  if (!isNaN(timeMs) && !isNaN(totalForce)) {
    const timeSec = (timeMs / 1000).toFixed(2);  // Convert to seconds

    fullData.push({ time: timeSec, load: totalForce });

    labels.push(timeSec + "s");   // X-axis = ESP time
    data.push(totalForce);       // Y-axis = force

    if (data.length > 50) {
      data.shift();
      labels.shift();
    }

    chart.update();
  } else {
    console.warn("‚ö†Ô∏è Could not parse number from BLE data:", parts);
  }
}
  </script>
</body>
</html>
